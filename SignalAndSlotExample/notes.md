# [Signal and Slots](https://doc.qt.io/qt-6/signalsandslots.html)

# Introduction

---

## In GUI programming
- When a widget is changed, we expect another widget to be notified
  - More generally, we want objects of any kind to communicate with one another.
  - Example : clicking the `Close` button we want the window's `close()` function to be called
- Other tool kits accomplish this type of communication using `callbacks`
  - A `callback` is a `pointer to a function`
  - If you want a processing function to `notify you` about an event you:
    - Pass a `pointer` to `another function; the callback` to the `processing function`
    - The `processing function` then calls the `callback` when appropriate 
      - There are frameworks that use this that are successful
      - But callbacks can be 
        - `Unintuitive`
        - Or have issues with ensuring type-correctness of callback arguments  
---


## Signals and Slots
- QT has an alternative to the `callback functions`
  - Uses `Signals and slots`
- A signal is emitted when a `particular event occurs`
- QT widgets have many predefined signals 
  - But we can always subclass widgets to `add our own signals` to them
- A `slot`
  - A `function` that's called in response to a particular signal 
  - QT has plenty of pre-defined slots 
  - It's common practice to `subclass widgets` and to `add your own slots` so you can handle the signals that you're interested in
- Signal/slot mechanism is `type safe`
  - `Type safe` : programming feature that prevents/discourages type errors by making sure the variables only access authorized memory locations in a well-defined way
    - Signature of signal `must match` signature of receiving slot
    - Since signals are compatible, the compiler can detect `type mismatches` when using the function pointer-based syntax
- Signals/slots are loosely coupled
  - A class that sends a signal neither know/cares which slot receives the signal
  - QT's signal/slot mechanism ensures if you connect a signal to a slot, the slot will be called with he signal's parameters at the right time
    - Signals/slots can take any number of arguments of any time and are considered type safe
- All classes that inherit from `QObject` or it's subclasses like `QWidget` contains signals/slots
  - `Signals` are emitted by objects when they change their state in a way that could be interesting to other objects 
  - The only thing the object does is `to communicate`
  - `Slots` used to receive signals 
    - They're also normal member functions 
    - Similar to an object not knowing if anything receive it's signal, `a slot doesn't know if it has any signals connected to it`
      - This ensures independent components can be made with QT
- You can connect `as many signals to a single slot`
- A signal can be `connected to as many slots as you need`
  - You can even `connect a signal directly to another signal`

---

## Signals
- Signals are sent to an object when it's `internal state has changed` that could be "interesting" to the object's client/owner
- Signals are `public access functions`
  - Can be emitted from anywhere
  - It's recommended to only emit them `from the class that defines the signal and it's subclasses`
- When a signal is emitted
  - Slots connected to it are typically `executed immediately` like a normal function call
  - When the signals are emitted
    - Signal/slot mechanisms are `totally independent` of any GUI event loop
    - Code execution following the emit statement will happen `once all slots have returned`
      - Situation is slightly different when it comes to `queued connections`
      - In this case, the code following the emit keyword will continue immediately 
        - Slots will be executed later
- If several slots connected to `one signal`
  - Slots will execute `one after another` in the order they've been connected once a signal is emitted
- Signals automatically generated by the `moc` 
  - AND MUST NOT BE IMPLEMENTED IN THE .CPP FILE

---

## Slots
- A slot is called when `a signal connected to it is emitted` 
- Slots are `normal C++ functions`
  - Can be called normally 
  - Only special feature about them is that the `signal can be connected to them`
- Since slots are `normal member function`
  - They follow normal C++ rules when called directly
  - But as slots
    - They can be invoked by `any component` regardless of it's `access levels` via the signal-slot connection
    - Meaning that a signal emitted from an instance of a class can cause a private slot to be invoked in an instance of an unrelated class
- Slots can also be defined to be `virtual` that could be useful in practice 
- Compared to callbacks
  - Signals and slots are `slightly slower` due to flexibility they provide
    - But in practice the difference aren't that noticeable
- In general
  - Emitting a signal that's connected to a slot is about `10 times slower` than calling the `receivers directly`
  - Due to the overhead required to `locate the connection object` to safely over all connection
    - Checking the subsequent receivers that haven't been destroyed during the emission
- Despite 10 non-virtual function calls may sound a lot, there's much less overhead in comparison to using the `new`/`delete` operations





